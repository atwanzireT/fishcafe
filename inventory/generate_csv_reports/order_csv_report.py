import csv
from datetime import datetime, timedelta
from django.http import HttpResponse
from django.utils import timezone
from django.contrib.auth.decorators import login_required
from inventory.models import OrderTransaction, OrderItem


@login_required(login_url='/user/login/')
def export_orders_to_csv(request, time_period='daily'):
    # Map period to filename and title
    period_map = {
        'daily': ('order_items_today.csv', 'DAILY ORDERS REPORT'),
        'weekly': ('order_items_this_week.csv', 'WEEKLY ORDERS REPORT'),
        'monthly': ('order_items_this_month.csv', 'MONTHLY ORDERS REPORT'),
        'biannual': ('order_items_this_biannual.csv', 'BIANNUAL ORDERS REPORT'),
        'annual': ('order_items_this_year.csv', 'ANNUAL ORDERS REPORT')
    }

    filename, heading = period_map.get(
        time_period, ('order_items.csv', 'ORDERS REPORT'))

    # Calculate date range
    today = timezone.localdate() 
    if time_period == 'daily':
        start_date = today
    elif time_period == 'weekly':
        start_date = today - timedelta(days=today.weekday())
    elif time_period == 'monthly':
        start_date = today.replace(day=1)
    elif time_period == 'biannual':
        start_date = today.replace(
            month=((today.month - 1) // 6) * 6 + 1, day=1)
    elif time_period == 'annual':
        start_date = today.replace(month=1, day=1)
    else:
        return HttpResponse("Invalid time period", status=400)

    # Make datetime aware
    start_of_period = timezone.make_aware(
        datetime.combine(start_date, datetime.min.time()))
    end_of_period = timezone.make_aware(datetime.combine(
        today + timedelta(days=1), datetime.min.time()))

    # Set up HTTP CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="{filename}"'

    writer = csv.writer(response)

    # Create a visual header with decorative borders

    writer.writerow([f' {heading} '])


    writer.writerow([])  # blank line

    # Enhanced column headers with visual emphasis
    column_headers = [
        ' ORDER DATE ', ' ORDER TIME ', ' TRANSACTION ID ',
        ' CATEGORY ', ' MENU ITEM ', ' QUANTITY ',
        ' UNIT PRICE ', ' TOTAL PRICE ', ' PAYMENT MODE ',
       ' SERVED BY ', ' GENERATED BY ',
        ' CUSTOMER NAME '
    ]

    # Add a separator line before headers

    writer.writerow(column_headers)
 

    # Query order transactions
    order_transactions = OrderTransaction.objects.select_related(
        'dining_area', 'table', 'created_by'
    ).filter(
        created__gte=start_of_period,
        created__lt=end_of_period,
        payment_mode__in=["CASH", "MOMO PAY", "BANK CARD", "AIRTEL PAY"]
    )

    total_sum = 0
    record_count = 0

    for order in order_transactions:
        order_items = OrderItem.objects.select_related(
            'menu_item__category').filter(order=order)
        for item in order_items:
            category_name = item.menu_item.category.name if item.menu_item and item.menu_item.category else 'N/A'
            writer.writerow([
                timezone.localtime(item.order_date).strftime('%Y-%m-%d'),
                timezone.localtime(item.order_date).strftime('%H:%M:%S'),
                order.random_id,
                category_name,
                item.menu_item.name if item.menu_item else 'N/A',
                item.quantity,
                float(item.menu_item.price) if item.menu_item else 0,
                float(item.total_price),
                order.payment_mode,
              
                order.served_by,
                order.created_by.username if order.created_by else 'Unknown',
                order.customer_name,
            ])
            total_sum += float(item.total_price)
            record_count += 1

    # Enhanced footer with summary
    writer.writerow([])
    writer.writerow([' SUMMARY '])
    writer.writerow([f'Total Records: {record_count}'])
    writer.writerow([f'Total Amount: Ugx{total_sum:.2f}'])


    return response
